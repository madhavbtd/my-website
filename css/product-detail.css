// js/product-detail.js
// FINAL Version: Includes Add-to-Cart Popup Fix, Wedding Qty Fix, Related Products Fix, SetupTabs Fix, showLoading Fix, Debug Logs. Uses 'onlineProducts'.

// --- Imports ---
import { db } from './firebase-config.js';
import { doc, getDoc, collection, query, where, limit, getDocs, addDoc, serverTimestamp, orderBy } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { addToCart } from './cart.js';
import { updateCartCount } from './main.js'; // Assuming main.js exports this

// --- DOM Elements ---
const productDetailContainer = document.getElementById('product-detail-container');
const loadingIndicator = productDetailContainer?.querySelector('.loading-indicator');
const productContent = productDetailContainer?.querySelector('.product-content');
const errorMessageContainer = document.getElementById('error-message-container');
const breadcrumbProductName = document.getElementById('breadcrumb-product-name');
const productNameEl = document.getElementById('product-name');
const mainImageEl = document.getElementById('main-product-image');
const thumbnailImagesContainer = document.getElementById('thumbnail-images');
const priceEl = document.getElementById('product-price');
const originalPriceEl = document.getElementById('original-price');
const perCardPriceEl = document.getElementById('per-card-price'); // Combined display area for per-card price
const weddingPerCardPriceEl = document.getElementById('wedding-per-card-price'); // Specific wedding per-card price
const addToCartBtn = document.getElementById('add-to-cart-btn');
const cartFeedbackEl = document.getElementById('cart-feedback-message');
const viewCartButton = document.getElementById('view-cart-button'); // Get the View Cart button

// Product Type Specific Containers
const standardOptionsContainer = document.getElementById('standard-options-container');
const weddingOptionsContainer = document.getElementById('wedding-options-container');
const flexOptionsContainer = document.getElementById('flex-options-container');

// Standard Quantity Controls
const quantityInput = document.getElementById('quantity');
const quantityDecreaseBtn = document.getElementById('quantity-decrease');
const quantityIncreaseBtn = document.getElementById('quantity-increase');

// Wedding Quantity Controls
const weddingQuantitySelect = document.getElementById('wedding-quantity-select');

// Flex Banner Controls
const bannerWidthInput = document.getElementById('banner-width');
const bannerHeightInput = document.getElementById('banner-height');
const bannerUnitSelect = document.getElementById('banner-unit');

// Popup Elements
const popupOverlay = document.getElementById('popup-overlay');
const popupProductName = document.getElementById('popup-product-name');
const popupProductImage = document.getElementById('popup-product-image');
const popupProductQuantity = document.getElementById('popup-product-quantity');
const popupProductOptions = document.getElementById('popup-product-options');
const popupProductPrice = document.getElementById('popup-product-price');
const popupPerCardPrice = document.getElementById('popup-per-card-price'); // Popup per card price element
const popupConfirmBtn = document.getElementById('popup-confirm-add');
const popupCancelBtn = document.getElementById('popup-cancel');
const popupCloseBtn = popupOverlay?.querySelector('.popup-close-btn'); // Assuming a close 'x' button might exist

// Related Products
const relatedProductsSection = document.getElementById('related-products-section');
const relatedProductsContainer = document.getElementById('related-products-container');

// Tabs
const tabsNav = document.querySelector('.tabs-nav');
const tabPanes = document.querySelectorAll('.tab-pane');

// Global variable to hold current product data
let currentProductData = null;
let currentPricingType = 'standard'; // 'standard', 'wedding', 'flex'
let currentPerCardPrice = 0; // Store the calculated per-card price for wedding cards

// --- Helper Functions ---
function showLoading(section = 'main') {
    console.log(`Showing loading for: ${section}`);
    if (section === 'main' && loadingIndicator && productContent) {
        loadingIndicator.style.display = 'flex';
        productContent.style.display = 'none';
        errorMessageContainer.style.display = 'none';
        if(relatedProductsSection) relatedProductsSection.style.display = 'none'; // Hide related products too
    } else if (section === 'related' && relatedProductsSection) {
        // Optional: Add a specific loader for related products if needed
        relatedProductsContainer.innerHTML = '<p>Loading related products...</p>';
        relatedProductsSection.style.display = 'block';
    }
}

function hideLoading(section = 'main') {
    console.log(`Hiding loading for: ${section}`);
    if (section === 'main' && loadingIndicator && productContent) {
        loadingIndicator.style.display = 'none';
        productContent.style.display = 'grid'; // Or 'block' depending on your layout
    }
    // No specific hiding for related needed if content replaces the loading text
}

function showError(message) {
    console.error("Error displayed:", message);
    if (errorMessageContainer && loadingIndicator && productContent) {
        errorMessageContainer.textContent = message;
        errorMessageContainer.style.display = 'block';
        loadingIndicator.style.display = 'none';
        productContent.style.display = 'none';
        if(relatedProductsSection) relatedProductsSection.style.display = 'none';
    } else {
        console.error("Error display elements not found.");
    }
}

function formatPrice(price) {
    return `â‚¹${Number(price).toLocaleString('en-IN', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
}

// --- Product Data Fetching & Rendering ---
async function loadProductDetails(productId) {
    showLoading('main');
    try {
        console.log(`Workspaceing product with ID: ${productId}`);
        const productRef = doc(db, "onlineProducts", productId); // Use 'onlineProducts' collection
        const productSnap = await getDoc(productRef);

        if (productSnap.exists()) {
            console.log("Product data found:", productSnap.data());
            currentProductData = { id: productSnap.id, ...productSnap.data() };
            renderProductDetails(currentProductData);
            // Don't fetch related products immediately, wait for main product render
        } else {
            console.error("No such product found!");
            showError("Product not found.");
        }
    } catch (error) {
        console.error("Error fetching product details:", error);
        showError("Could not load product details. Please check your connection and try again.");
    } finally {
        // Main loading hidden inside renderProductDetails or showError
    }
}

function renderProductDetails(productData) {
    console.log("Rendering product details...");

    if (!productData || !productDetailContainer) {
        showError("Failed to render product details: Data or container missing.");
        return;
    }

    // Determine pricing type
    if (productData.pricingType === 'wedding') {
        currentPricingType = 'wedding';
    } else if (productData.pricingType === 'flex') {
        currentPricingType = 'flex';
    } else {
        currentPricingType = 'standard';
    }
    console.log(`Product pricing type determined as: ${currentPricingType}`);

    // --- Update Basic Info ---
    if (breadcrumbProductName) breadcrumbProductName.textContent = productData.name || 'Product';
    if (productNameEl) productNameEl.textContent = productData.name || 'N/A';
    document.title = `${productData.name || 'Product'} Details - Madhav Multiprint`;

    // --- Update Images ---
    if (mainImageEl) {
        mainImageEl.src = productData.imageUrls?.[0] || 'images/placeholder.png';
        mainImageEl.alt = productData.name || 'Product Image';
    }
    if (thumbnailImagesContainer) {
        thumbnailImagesContainer.innerHTML = ''; // Clear old thumbnails
        if (productData.imageUrls && productData.imageUrls.length > 1) {
            productData.imageUrls.forEach((url, index) => {
                const img = document.createElement('img');
                img.src = url;
                img.alt = `Thumbnail ${index + 1}`;
                img.dataset.full = url;
                if (index === 0) img.classList.add('active');
                img.addEventListener('click', () => {
                    if (mainImageEl) mainImageEl.src = img.dataset.full;
                    thumbnailImagesContainer.querySelectorAll('img').forEach(i => i.classList.remove('active'));
                    img.classList.add('active');
                });
                thumbnailImagesContainer.appendChild(img);
            });
            thumbnailImagesContainer.style.display = 'grid';
        } else {
             thumbnailImagesContainer.style.display = 'none'; // Hide thumbnails if only one image
        }
    }

    // --- Update Descriptions ---
    const shortDescEl = document.querySelector('.product-description-short');
    if (shortDescEl) shortDescEl.textContent = productData.shortDescription || '';
    const longDescEl = document.getElementById('tab-description');
    if (longDescEl) longDescEl.innerHTML = productData.longDescription || '<p>No description available.</p>'; // Use innerHTML if description contains HTML

    // --- Update Specifications ---
    const specsList = document.getElementById('tab-specifications ul');
    if (specsList) {
        specsList.innerHTML = ''; // Clear existing specs
        if (productData.specifications && typeof productData.specifications === 'object') {
            for (const [key, value] of Object.entries(productData.specifications)) {
                if (value) { // Only display specs with a value
                    const li = document.createElement('li');
                    const strong = document.createElement('strong');
                    strong.textContent = key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase()); // Format key nicely
                    const span = document.createElement('span');
                    span.textContent = value;
                    li.appendChild(strong);
                    li.appendChild(span);
                    specsList.appendChild(li);
                }
            }
        } else {
            specsList.innerHTML = '<li>No specifications available.</li>';
        }
    }


    // --- Update Pricing & Options ---
    updatePricingAndOptionsVisibility(productData);

    // --- Setup Event Listeners (Crucial: After elements are rendered) ---
    attachEventListeners(productData); // Attach listeners for quantity, add to cart etc.

    // --- Update Schema.org JSON-LD ---
    updateProductSchema(productData);

    // --- Fetch and Render Related Products ---
    if (productData.category) {
        loadRelatedProducts(productData.category, productData.id);
    } else {
        console.log("No category found, skipping related products.");
        if(relatedProductsSection) relatedProductsSection.style.display = 'none';
    }

    // --- Fetch and Render Reviews ---
    loadReviews(productData.id);

    // --- Setup Tabs ---
    setupTabs(); // Make sure tabs work

     // --- Hide Loading, Show Content ---
    hideLoading('main');
    console.log("Product details rendered successfully.");
}

function updatePricingAndOptionsVisibility(productData) {
    console.log("Updating pricing and options visibility based on type:", currentPricingType);
    // Hide all option containers initially
    if (standardOptionsContainer) standardOptionsContainer.style.display = 'none';
    if (weddingOptionsContainer) weddingOptionsContainer.style.display = 'none';
    if (flexOptionsContainer) flexOptionsContainer.style.display = 'none';
    if (originalPriceEl) originalPriceEl.style.display = 'none'; // Hide original price by default
    if (perCardPriceEl) perCardPriceEl.style.display = 'none'; // Hide general per-card price display
    if (weddingPerCardPriceEl) weddingPerCardPriceEl.style.display = 'none'; // Hide specific wedding per-card price display

    switch (currentPricingType) {
        case 'wedding':
            if (weddingOptionsContainer) weddingOptionsContainer.style.display = 'block';
            if (weddingQuantitySelect && productData.weddingPricing) {
                populateWeddingQuantities(productData.weddingPricing);
                updateWeddingPriceDisplay(); // Initial price update
            } else {
                 console.error("Wedding pricing data or select element missing.");
                 if (priceEl) priceEl.textContent = 'Price Unavailable';
            }
            break;
        case 'flex':
            if (flexOptionsContainer) flexOptionsContainer.style.display = 'block';
            if (bannerWidthInput && bannerHeightInput && bannerUnitSelect && productData.basePriceSqFt) {
                updateFlexPriceDisplay(); // Initial price update
            } else {
                console.error("Flex pricing elements or base price missing.");
                if (priceEl) priceEl.textContent = 'Price Unavailable';
            }
            break;
        case 'standard':
        default:
            if (standardOptionsContainer) standardOptionsContainer.style.display = 'block';
            if (priceEl) priceEl.textContent = formatPrice(productData.price || 0);
            if (productData.originalPrice && productData.originalPrice > productData.price) {
                if (originalPriceEl) {
                    originalPriceEl.textContent = formatPrice(productData.originalPrice);
                    originalPriceEl.style.display = 'inline';
                }
            }
            if (quantityInput) quantityInput.value = 1; // Reset quantity
            break;
    }
}

function populateWeddingQuantities(pricingTiers) {
    if (!weddingQuantitySelect || !pricingTiers || pricingTiers.length === 0) return;

    // Sort tiers by quantity ascending
    pricingTiers.sort((a, b) => a.minQuantity - b.minQuantity);

    weddingQuantitySelect.innerHTML = ''; // Clear existing options
    pricingTiers.forEach(tier => {
        const option = document.createElement('option');
        option.value = tier.minQuantity; // Use minQuantity as the value
        option.dataset.pricePerCard = tier.pricePerCard; // Store price per card in data attribute
        option.textContent = `${tier.minQuantity}+ Cards`;
        weddingQuantitySelect.appendChild(option);
    });
    weddingQuantitySelect.selectedIndex = 0; // Select the first option by default
}

function updateWeddingPriceDisplay() {
    if (!weddingQuantitySelect || !priceEl || !weddingPerCardPriceEl) return;

    const selectedOption = weddingQuantitySelect.options[weddingQuantitySelect.selectedIndex];
    if (!selectedOption || !selectedOption.dataset.pricePerCard) {
        console.error("Selected wedding option or price data missing.");
        priceEl.textContent = 'N/A';
        weddingPerCardPriceEl.textContent = '';
        weddingPerCardPriceEl.style.display = 'none';
        return;
    }

    const quantity = parseInt(selectedOption.value, 10);
    currentPerCardPrice = parseFloat(selectedOption.dataset.pricePerCard); // Update global per-card price
    const totalPrice = quantity * currentPerCardPrice;

    priceEl.textContent = formatPrice(totalPrice);
    weddingPerCardPriceEl.textContent = `${formatPrice(currentPerCardPrice)} per card`;
    weddingPerCardPriceEl.style.display = 'block'; // Show the per-card price

    console.log(`Wedding price updated: Qty=${quantity}, PerCard=${currentPerCardPrice}, Total=${totalPrice}`);
}


function updateFlexPriceDisplay() {
    if (!bannerWidthInput || !bannerHeightInput || !bannerUnitSelect || !priceEl || !currentProductData?.basePriceSqFt) {
         console.warn("Flex pricing update skipped: Missing elements or base price.");
         return;
    }

    const width = parseFloat(bannerWidthInput.value) || 0;
    const height = parseFloat(bannerHeightInput.value) || 0;
    const unit = bannerUnitSelect.value;
    const basePriceSqFt = parseFloat(currentProductData.basePriceSqFt);

    if (width <= 0 || height <= 0 || !basePriceSqFt) {
        priceEl.textContent = formatPrice(0);
        return;
    }

    let areaSqFt = 0;
    if (unit === 'ft') {
        areaSqFt = width * height;
    } else if (unit === 'in') {
        areaSqFt = (width / 12) * (height / 12);
    } else if (unit === 'cm') {
        areaSqFt = (width / 30.48) * (height / 30.48);
    }

    const totalPrice = areaSqFt * basePriceSqFt;
    priceEl.textContent = formatPrice(totalPrice);
    console.log(`Flex price updated: W=${width}, H=${height}, Unit=${unit}, AreaSqFt=${areaSqFt.toFixed(2)}, Total=${totalPrice}`);
}

function updateProductSchema(productData) {
    const schemaScript = document.getElementById('product-schema');
    if (schemaScript) {
        try {
            const schema = {
                "@context": "https://schema.org/",
                "@type": "Product",
                "name": productData.name || "Unnamed Product",
                "image": productData.imageUrls || [],
                "description": productData.shortDescription || productData.longDescription || "No description available.",
                "sku": productData.sku || productData.id, // Use SKU if available, else product ID
                "brand": {
                    "@type": "Brand",
                    "name": "Madhav Multiprint" // Assuming a fixed brand name
                },
                "offers": {
                    "@type": "Offer",
                    "url": window.location.href, // Current page URL
                    "priceCurrency": "INR",
                    // Price determination needs logic based on pricingType
                    "price": determineSchemaPrice(productData),
                    "availability": "https://schema.org/InStock", // Assuming always in stock for now
                    "priceValidUntil": new Date(new Date().setDate(new Date().getDate() + 30)).toISOString().substring(0,10) // Valid for 30 days example
                },
                // Optional: Add aggregateRating if reviews are implemented
                // "aggregateRating": {
                //   "@type": "AggregateRating",
                //   "ratingValue": "4.5", // Example
                //   "reviewCount": "15" // Example
                // },
                // Optional: Add reviews
                // "review": [ { ... review schema ... } ]
            };
            schemaScript.textContent = JSON.stringify(schema, null, 2); // Pretty print JSON
             console.log("Product schema updated.");
        } catch (e) {
            console.error("Error updating product schema:", e);
        }
    }
}

function determineSchemaPrice(productData) {
    // Provides a representative price for Schema.org
    // For variable pricing, using the base or lowest tier price is common.
    switch (productData.pricingType) {
        case 'wedding':
            // Use the price of the lowest quantity tier
            return productData.weddingPricing?.sort((a,b) => a.minQuantity - b.minQuantity)[0]?.pricePerCard * productData.weddingPricing[0]?.minQuantity || "0";
        case 'flex':
            // Flex price depends on dimensions, maybe provide base price per sq ft?
            // Or calculate for a default size (e.g., 1x1 ft). Let's use 0 for now or base price.
            return productData.basePriceSqFt || "0"; // Representing price per sq ft
        case 'standard':
        default:
            return productData.price || "0";
    }
}

// --- Event Listeners Setup ---
// Store references to listeners to allow removal
let handleAddToCartListener;
let standardQuantityButtonListener;
let weddingQuantityChangeListener;
let flexInputListeners = []; // Store multiple listeners for flex inputs

function attachEventListeners(productData) {
    console.log("Attaching event listeners...");

    // --- Remove Previous Listeners (IMPORTANT) ---
    // This prevents duplicate listeners if renderProductDetails is somehow called again
    if (addToCartBtn && handleAddToCartListener) {
        addToCartBtn.removeEventListener('click', handleAddToCartListener);
        console.log("Removed previous Add to Cart listener.");
    }
    if (quantityDecreaseBtn && standardQuantityButtonListener) {
        quantityDecreaseBtn.removeEventListener('click', standardQuantityButtonListener);
    }
    if (quantityIncreaseBtn && standardQuantityButtonListener) {
        quantityIncreaseBtn.removeEventListener('click', standardQuantityButtonListener);
         console.log("Removed previous standard quantity listeners.");
    }
    if (weddingQuantitySelect && weddingQuantityChangeListener) {
        weddingQuantitySelect.removeEventListener('change', weddingQuantityChangeListener);
        console.log("Removed previous wedding quantity listener.");
    }
    // Remove previous flex listeners
    flexInputListeners.forEach(({ element, type, listener }) => {
        if (element) element.removeEventListener(type, listener);
    });
    flexInputListeners = []; // Clear the array
    console.log("Removed previous flex input listeners.");


    // --- Add New Listeners ---

    // Add to Cart Button
    if (addToCartBtn) {
        handleAddToCartListener = () => handleAddToCart(productData); // Define the listener
        addToCartBtn.addEventListener('click', handleAddToCartListener);
        console.log("Add to Cart button listener attached.");
    } else {
        console.error("Add to Cart button not found.");
    }

    // Standard Quantity Controls
    if (quantityDecreaseBtn && quantityIncreaseBtn && quantityInput && currentPricingType === 'standard') {
        standardQuantityButtonListener = (event) => handleStandardQuantityChange(event.target); // Define listener
        quantityDecreaseBtn.addEventListener('click', standardQuantityButtonListener);
        quantityIncreaseBtn.addEventListener('click', standardQuantityButtonListener);
        console.log("Standard quantity button listeners attached.");
    }

    // Wedding Quantity Select
    if (weddingQuantitySelect && currentPricingType === 'wedding') {
        weddingQuantityChangeListener = updateWeddingPriceDisplay; // Define listener
        weddingQuantitySelect.addEventListener('change', weddingQuantityChangeListener);
        console.log("Wedding quantity select listener attached.");
    }

    // Flex Input Controls
    if (currentPricingType === 'flex') {
        const inputs = [bannerWidthInput, bannerHeightInput, bannerUnitSelect];
        if (inputs.every(el => el)) { // Check if all elements exist
            inputs.forEach(input => {
                const eventType = (input.tagName === 'SELECT') ? 'change' : 'input';
                const listener = updateFlexPriceDisplay; // Define listener
                input.addEventListener(eventType, listener);
                flexInputListeners.push({ element: input, type: eventType, listener }); // Store listener info
            });
             console.log("Flex input listeners attached.");
        } else {
             console.error("One or more flex input elements not found.");
        }
    }
}


function handleStandardQuantityChange(button) {
    if (!quantityInput) return;
    let currentValue = parseInt(quantityInput.value, 10) || 1;
    const min = parseInt(quantityInput.min, 10) || 1;
    const step = parseInt(quantityInput.step, 10) || 1;

    if (button.classList.contains('quantity-increase')) {
        currentValue += step;
    } else if (button.classList.contains('quantity-decrease')) {
        currentValue -= step;
    }

    quantityInput.value = Math.max(min, currentValue);
    // Note: Standard pricing doesn't usually change with quantity here, price is per item.
    // If price *did* depend on quantity, you'd update the price display here.
    console.log(`Standard quantity updated to: ${quantityInput.value}`);
}


// --- Add to Cart Logic ---
function handleAddToCart(productData) {
    console.log(`'Add to Cart' clicked for product: ${productData.id}`);
    if (!productData) {
        console.error("Cannot add to cart: Product data is missing.");
        showCartFeedback("Error: Product data unavailable.", "error");
        return;
    }

    let quantity = 1;
    let price = productData.price || 0;
    let options = {}; // Collect selected options
    let itemPerCardPrice = null; // Specifically for wedding cards

    try {
        switch (currentPricingType) {
            case 'wedding':
                if (!weddingQuantitySelect || weddingQuantitySelect.selectedIndex < 0) {
                    throw new Error("Please select a quantity for wedding cards.");
                }
                const selectedWeddingOption = weddingQuantitySelect.options[weddingQuantitySelect.selectedIndex];
                quantity = parseInt(selectedWeddingOption.value, 10);
                itemPerCardPrice = parseFloat(selectedWeddingOption.dataset.pricePerCard);
                price = quantity * itemPerCardPrice; // Total price for the selected quantity
                options['Quantity Tier'] = `${quantity}+ Cards`;
                options['Price Per Card'] = formatPrice(itemPerCardPrice);
                break;
            case 'flex':
                if (!bannerWidthInput || !bannerHeightInput || !bannerUnitSelect || !priceEl) {
                     throw new Error("Flex banner details incomplete.");
                }
                 const width = parseFloat(bannerWidthInput.value) || 0;
                 const height = parseFloat(bannerHeightInput.value) || 0;
                 const unit = bannerUnitSelect.value;
                 if (width <= 0 || height <= 0) {
                     throw new Error("Please enter valid dimensions for the flex banner.");
                 }
                 price = parseFloat(priceEl.textContent.replace(/[^0-9.]/g, '')); // Get price from display
                 quantity = 1; // Flex is usually sold as one unit with specific dimensions
                 options['Dimensions'] = `${width} x ${height} ${unit}`;
                break;
            case 'standard':
            default:
                if (!quantityInput) {
                     throw new Error("Quantity input not found.");
                 }
                quantity = parseInt(quantityInput.value, 10) || 1;
                if (quantity < 1) {
                     throw new Error("Quantity must be at least 1.");
                 }
                price = productData.price * quantity; // Total price
                // Add other standard options if they exist (e.g., size, color dropdowns)
                // options['Size'] = document.getElementById('size-select')?.value;
                break;
        }

        if (isNaN(price) || price <= 0 && !(currentPricingType === 'flex' && price === 0)) { // Allow 0 price only if flex might calculate to 0 initially
             throw new Error("Invalid price calculated. Please check options.");
        }


        const itemDetails = {
            quantity: quantity,
            price: price, // Total price for the item/quantity
            options: options,
            perCardPrice: itemPerCardPrice // Will be null for non-wedding items
        };

        console.log("Item details prepared for popup:", itemDetails);
        showConfirmationPopup(itemDetails, productData);

    } catch (error) {
        console.error("Error preparing item for cart:", error);
        showCartFeedback(error.message || "Could not prepare item. Please check selections.", "error");
    }
}

// --- Popup Management ---
// Store listener functions to allow proper removal
let handleConfirmAdd;
let handleCancelPopup;
let handleClosePopup;

function showConfirmationPopup(itemDetails, productData) {
    console.log("Showing confirmation popup...");
    if (!popupOverlay || !productData || !itemDetails) {
        console.error("Popup elements, product data, or item details missing.");
        return;
    }

    // Populate Popup Content
    popupProductName.textContent = productData.name || 'Product';
    popupProductImage.src = productData.imageUrls?.[0] || 'images/placeholder.png';
    popupProductImage.alt = productData.name || 'Product';
    popupProductQuantity.textContent = itemDetails.quantity;
    popupProductPrice.textContent = formatPrice(itemDetails.price); // Display total price

    // Display options
    let optionsText = Object.entries(itemDetails.options)
        .map(([key, value]) => `<strong>${key}:</strong> ${value}`)
        .join('<br>');
    popupProductOptions.innerHTML = optionsText;

    // Display per-card price only for wedding cards
    if (itemDetails.perCardPrice !== null) {
        popupPerCardPrice.textContent = `${formatPrice(itemDetails.perCardPrice)} per card`;
        popupPerCardPrice.style.display = 'block';
    } else {
        popupPerCardPrice.textContent = '';
        popupPerCardPrice.style.display = 'none';
    }


    // Define listeners *before* adding them
    handleConfirmAdd = () => {
        console.log("Confirm button clicked.");
        try {
            addToCart(
                productData.id,
                itemDetails.quantity,
                itemDetails.price / itemDetails.quantity, // Send unit price to cart function
                productData.name,
                productData.imageUrls?.[0] || 'images/placeholder.png',
                itemDetails.options,
                itemDetails.perCardPrice // Pass perCardPrice if available
            );
            showCartFeedback("Item added successfully!", "success", true); // Show feedback and View Cart button
            updateCartCount(); // Update header cart count
        } catch (error) {
            console.error("Error adding item to cart:", error);
            showCartFeedback("Error adding item to cart. Please try again.", "error");
        } finally {
            hidePopup();
        }
    };

    handleCancelPopup = () => {
        console.log("Cancel button clicked.");
        hidePopup();
    };

    handleClosePopup = () => {
         console.log("Popup close button clicked.");
         hidePopup();
    }


    // *** Remove existing listeners before adding new ones ***
    popupConfirmBtn.removeEventListener('click', handleConfirmAdd);
    popupCancelBtn.removeEventListener('click', handleCancelPopup);
    popupCloseBtn?.removeEventListener('click', handleClosePopup); // Use optional chaining for close button

    // Add new listeners
    popupConfirmBtn.addEventListener('click', handleConfirmAdd);
    popupCancelBtn.addEventListener('click', handleCancelPopup);
    popupCloseBtn?.addEventListener('click', handleClosePopup); // Use optional chaining

    // Show Popup
    popupOverlay.classList.add('active');
     console.log("Popup displayed and listeners attached.");
}

function hidePopup() {
    if (!popupOverlay) return;
    console.log("Hiding popup...");
    popupOverlay.classList.remove('active');

    // *** Remove listeners on hide ***
    popupConfirmBtn.removeEventListener('click', handleConfirmAdd);
    popupCancelBtn.removeEventListener('click', handleCancelPopup);
    popupCloseBtn?.removeEventListener('click', handleClosePopup); // Use optional chaining

     console.log("Popup hidden and listeners removed.");

    // Optional: Reset stored listener functions if desired, though removing them is the key part
    handleConfirmAdd = null;
    handleCancelPopup = null;
    handleClosePopup = null;
}

// --- Cart Feedback ---
function showCartFeedback(message, type = 'success', showViewCart = false) {
    if (!cartFeedbackEl) return;

    console.log(`Cart Feedback (${type}): ${message}`);
    cartFeedbackEl.textContent = message;
    cartFeedbackEl.className = `cart-feedback-message ${type}`; // Reset classes and add new ones
    cartFeedbackEl.style.display = 'block';

    // Show/Hide View Cart button based on success
     if (viewCartButton) {
        viewCartButton.style.display = showViewCart ? 'inline-flex' : 'none';
     }


    // Optional: Hide message after a delay
    // setTimeout(() => {
    //     cartFeedbackEl.style.display = 'none';
    //      if (viewCartButton) viewCartButton.style.display = 'none'; // Hide button with message
    // }, 5000); // Hide after 5 seconds
}

// --- Related Products ---
async function loadRelatedProducts(category, currentProductId) {
    if (!relatedProductsSection || !relatedProductsContainer) {
        console.log("Related products section/container not found, skipping.");
        return;
    }
    showLoading('related'); // Indicate loading specifically for this section

    try {
        console.log(`Workspaceing related products for category: ${category}, excluding ID: ${currentProductId}`);
        const productsRef = collection(db, "onlineProducts");
        // Query for products in the same category, exclude the current one, limit results
        const q = query(
            productsRef,
            where("category", "==", category),
            // where(doc.id, "!=", currentProductId), // Firestore doesn't support direct inequality on ID in compound queries easily
            limit(10) // Limit the number of related products
        );
        const querySnapshot = await getDocs(q);

        relatedProductsContainer.innerHTML = ''; // Clear previous content/loader
        let count = 0;
        const slides = [];

        querySnapshot.forEach((docSnap) => {
            // Manual check to exclude the current product
            if (docSnap.id !== currentProductId) {
                 const product = { id: docSnap.id, ...docSnap.data() };
                 // Only include products with necessary info (name, price, image)
                 if (product.name && (product.price || product.weddingPricing || product.basePriceSqFt) && product.imageUrls?.[0]) {
                    slides.push(createRelatedProductSlide(product));
                    count++;
                 } else {
                     console.warn(`Skipping related product (${product.id}) due to missing data.`);
                 }

            }
        });

        if (count > 0) {
            relatedProductsContainer.innerHTML = slides.join(''); // Add all slides at once
            relatedProductsSection.style.display = 'block'; // Show the section
            initializeRelatedProductsSwiper(); // Initialize Swiper AFTER adding slides
             console.log(`Loaded ${count} related products.`);
        } else {
            relatedProductsSection.style.display = 'none'; // Hide section if no related products found
             console.log("No suitable related products found.");
        }

    } catch (error) {
        console.error("Error fetching related products:", error);
        relatedProductsContainer.innerHTML = '<p>Could not load related products.</p>'; // Show error in container
        relatedProductsSection.style.display = 'block'; // Ensure section is visible to show the error
    }
}

function createRelatedProductSlide(product) {
    const priceDisplay = getProductPriceForCard(product); // Get appropriate price display
    const imageUrl = product.imageUrls?.[0] || 'images/placeholder.png';
    const productUrl = `product-detail.html?id=${product.id}`;

    // Using Swiper slide structure
    return `
        <div class="swiper-slide">
            <div class="product-card">
                <a href="${productUrl}" class="product-image-container">
                    <img src="${imageUrl}" alt="${product.name || 'Product'}" loading="lazy">
                </a>
                <div class="product-info">
                    <h3><a href="${productUrl}">${product.name || 'N/A'}</a></h3>
                    <div class="price">${priceDisplay}</div>
                    <a href="${productUrl}" class="view-details-btn">View Details</a>
                </div>
            </div>
        </div>
    `;
}

function getProductPriceForCard(product) {
    // Helper to display a representative price on the product card
    switch (product.pricingType) {
        case 'wedding':
            const lowestTier = product.weddingPricing?.sort((a,b) => a.minQuantity - b.minQuantity)[0];
            return lowestTier ? `${formatPrice(lowestTier.pricePerCard)}/card (for ${lowestTier.minQuantity}+)` : 'Price Varies';
        case 'flex':
            return product.basePriceSqFt ? `${formatPrice(product.basePriceSqFt)}/sq.ft` : 'Price Varies';
        case 'standard':
        default:
            return formatPrice(product.price || 0);
    }
}


function initializeRelatedProductsSwiper() {
    // Ensure Swiper library is loaded before calling this
     if (typeof Swiper === 'undefined') {
         console.error("Swiper library is not loaded.");
         return;
     }

     // Check if a Swiper instance already exists on the container and destroy it
    if (relatedProductsContainer.swiper) {
        relatedProductsContainer.swiper.destroy(true, true);
         console.log("Destroyed existing Swiper instance.");
    }


    // Initialize Swiper
    const swiper = new Swiper('.related-products-swiper', {
        slidesPerView: 2, // Show 2 slides on mobile initially
        spaceBetween: 15,
        pagination: {
            el: '.swiper-pagination',
            clickable: true,
        },
        navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
        },
        breakpoints: {
            // when window width is >= 576px
            576: {
                slidesPerView: 2,
                spaceBetween: 20
            },
            // when window width is >= 768px
            768: {
                slidesPerView: 3,
                spaceBetween: 25
            },
            // when window width is >= 992px
            992: {
                slidesPerView: 4,
                spaceBetween: 30
            },
             // when window width is >= 1200px
             1200: {
                slidesPerView: 5,
                spaceBetween: 30
             }
        },
         // Add observer and observeParents for dynamic content loading
         observer: true,
         observeParents: true,
    });
     console.log("Related products Swiper initialized.");
}


// --- Tabs ---
function setupTabs() {
     if (!tabsNav || !tabPanes.length) {
          console.warn("Tabs setup skipped: Nav or panes not found.");
          return; // Exit if tabs elements aren't present
     }

     console.log("Setting up tabs...");

    // Set the first tab and pane as active by default
    const firstTabLink = tabsNav.querySelector('li a');
    const firstPaneId = firstTabLink?.getAttribute('href');
    if (firstTabLink && firstPaneId) {
        tabsNav.querySelectorAll('li a').forEach(link => link.classList.remove('active'));
        tabPanes.forEach(pane => pane.classList.remove('active'));

        firstTabLink.classList.add('active');
        const firstPane = document.querySelector(firstPaneId);
        if (firstPane) {
            firstPane.classList.add('active');
            console.log(`Default active tab set to: ${firstPaneId}`);
        } else {
             console.error(`Default active pane (${firstPaneId}) not found.`);
        }

    } else {
         console.warn("Could not set default active tab.");
    }


    // Add click event listener to the navigation container (event delegation)
    tabsNav.addEventListener('click', (e) => {
        // Check if the clicked element is a tab link (<a> tag)
        if (e.target.tagName === 'A' && e.target.getAttribute('href').startsWith('#')) {
            e.preventDefault(); // Prevent default anchor link behavior

            const targetPaneId = e.target.getAttribute('href');
            console.log(`Tab clicked: ${targetPaneId}`);

            // Remove 'active' class from all tab links and panes
            tabsNav.querySelectorAll('li a').forEach(link => link.classList.remove('active'));
            tabPanes.forEach(pane => pane.classList.remove('active'));

            // Add 'active' class to the clicked tab link
            e.target.classList.add('active');

            // Add 'active' class to the corresponding tab pane
            const targetPane = document.querySelector(targetPaneId);
            if (targetPane) {
                targetPane.classList.add('active');
            } else {
                console.error(`Target pane (${targetPaneId}) not found.`);
            }
        }
    });
     console.log("Tab click listeners ready.");
}


// --- Reviews ---
async function loadReviews(productId) {
    const reviewsList = document.getElementById('reviews-list');
    const reviewsSummary = document.querySelector('.reviews-summary'); // Element to show average rating/count
    if (!reviewsList || !reviewsSummary) {
         console.warn("Reviews list or summary element not found, skipping review loading.");
         return;
    }

    reviewsList.innerHTML = '<li>Loading reviews...</li>'; // Indicate loading
    reviewsSummary.textContent = ''; // Clear summary

    try {
        console.log(`Workspaceing reviews for product ID: ${productId}`);
        const reviewsRef = collection(db, "onlineProducts", productId, "reviews");
        const q = query(reviewsRef, orderBy("timestamp", "desc")); // Get newest reviews first
        const querySnapshot = await getDocs(q);

        reviewsList.innerHTML = ''; // Clear loading message
        let totalRating = 0;
        let reviewCount = 0;

        if (querySnapshot.empty) {
            reviewsList.innerHTML = '<li>Be the first to review this product!</li>';
             reviewsSummary.textContent = 'No reviews yet.';
        } else {
            querySnapshot.forEach((doc) => {
                const review = doc.data();
                if (review.rating && review.comment && review.userName) { // Basic validation
                    const li = document.createElement('li');
                    li.classList.add('review-item');
                    li.innerHTML = `
                        <div class="review-rating">${generateStarRating(review.rating)}</div>
                        <p class="review-comment">${escapeHTML(review.comment)}</p>
                        <p class="review-meta">By <strong>${escapeHTML(review.userName)}</strong> on ${review.timestamp?.toDate().toLocaleDateString() || 'N/A'}</p>
                    `;
                    reviewsList.appendChild(li);
                    totalRating += Number(review.rating);
                    reviewCount++;
                }
            });

            if (reviewCount > 0) {
                 const averageRating = (totalRating / reviewCount).toFixed(1);
                 reviewsSummary.innerHTML = `Average Rating: ${generateStarRating(averageRating)} (${averageRating} out of 5) based on ${reviewCount} review(s).`;
                 console.log(`Loaded ${reviewCount} reviews. Average rating: ${averageRating}`);
            } else {
                 reviewsList.innerHTML = '<li>No valid reviews found.</li>';
                 reviewsSummary.textContent = 'No reviews yet.';
            }

        }
    } catch (error) {
        console.error("Error fetching reviews:", error);
        reviewsList.innerHTML = '<li>Could not load reviews. Please try again later.</li>';
         reviewsSummary.textContent = 'Could not load rating.';
    }

    // Setup review form listener (do this regardless of whether reviews were loaded)
    setupReviewForm(productId);
}

function generateStarRating(rating) {
    const totalStars = 5;
    let starsHTML = '';
    const fullStars = Math.floor(rating);
    const halfStar = rating % 1 >= 0.5 ? 1 : 0;
    const emptyStars = totalStars - fullStars - halfStar;

    for (let i = 0; i < fullStars; i++) starsHTML += '<i class="fas fa-star"></i>';
    if (halfStar) starsHTML += '<i class="fas fa-star-half-alt"></i>';
    for (let i = 0; i < emptyStars; i++) starsHTML += '<i class="far fa-star"></i>'; // Use far for empty stars

    return starsHTML || 'No Rating'; // Handle case where rating might be 0 or invalid
}

function setupReviewForm(productId) {
    const reviewForm = document.getElementById('review-form');
    const formMessage = document.getElementById('review-form-message');
    if (!reviewForm || !formMessage) {
        console.warn("Review form or message element not found, skipping setup.");
        return;
    }

     console.log("Setting up review form listener.");

    reviewForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        formMessage.textContent = '';
        formMessage.className = ''; // Clear previous status classes
        const submitButton = reviewForm.querySelector('button[type="submit"]');
        submitButton.disabled = true;
        submitButton.textContent = 'Submitting...';

        try {
            const rating = reviewForm.querySelector('input[name="rating"]:checked')?.value;
            const userName = reviewForm.querySelector('#reviewer-name').value.trim();
            const comment = reviewForm.querySelector('#review-comment').value.trim();

            if (!rating || !userName || !comment) {
                throw new Error("Please fill in all fields and select a rating.");
            }
            if (userName.length < 2) {
                 throw new Error("Name must be at least 2 characters long.");
            }
             if (comment.length < 10) {
                 throw new Error("Comment must be at least 10 characters long.");
            }


            const reviewsRef = collection(db, "onlineProducts", productId, "reviews");
            await addDoc(reviewsRef, {
                rating: Number(rating),
                userName: userName,
                comment: comment,
                timestamp: serverTimestamp()
            });

            formMessage.textContent = 'Review submitted successfully! Thank you.';
            formMessage.className = 'success'; // Add success class
            reviewForm.reset(); // Clear the form
             console.log("Review submitted.");

            // Optional: Reload reviews after submission
             setTimeout(() => loadReviews(productId), 1000); // Reload after 1 second

        } catch (error) {
            console.error("Error submitting review:", error);
            formMessage.textContent = `Error: ${error.message || "Could not submit review."}`;
            formMessage.className = 'error'; // Add error class
        } finally {
             submitButton.disabled = false;
             submitButton.textContent = 'Submit Review';
        }
    });
}

// Utility to escape HTML to prevent XSS
function escapeHTML(str) {
    if (!str) return '';
    const div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
}


// --- Initialize Page ---
document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM fully loaded.");
    const urlParams = new URLSearchParams(window.location.search);
    const productId = urlParams.get('id');

    if (!productId) {
        showError("Product ID not found in URL. Please go back to the shop and select a product.");
        return;
    }

    console.log(`Initializing page for Product ID: ${productId}`);
    loadProductDetails(productId); // Fetch data and render, includes attaching event listeners

    // Initial cart count update on page load
    updateCartCount();
});